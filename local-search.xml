<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ros2</title>
    <link href="/2025/06/11/ros2/"/>
    <url>/2025/06/11/ros2/</url>
    
    <content type="html"><![CDATA[<h1 id="功能包（pkg）"><a href="#功能包（pkg）" class="headerlink" title="功能包（pkg）"></a>功能包（pkg）</h1><p>一个功能包可以被认为是ROS2代码的容器。如果希望能够管理代码或与他人共享代码，那么需要将其组织在一个包中。通过包，可以发布ROS2工作，并允许其他人轻松地构建和使用它。</p><h2 id="功能包-和-程序-的关系"><a href="#功能包-和-程序-的关系" class="headerlink" title="功能包 和 程序 的关系"></a>功能包 和 程序 的关系</h2><p>一个功能包里可以包含多个程序。这些程序分成不同职责，共同构成一个功能包的完整功能。通过cmake可控制多个可执行文件：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># ...</span><br><span class="hljs-keyword">add_executable</span>(program1 src/program1.cpp ...)<br><span class="hljs-comment"># ...</span><br><span class="hljs-keyword">add_executable</span>(program2 src/program2.cpp ...)<br><span class="hljs-comment"># ...</span><br></code></pre></td></tr></table></figure><h2 id="程序-和-节点-的关系"><a href="#程序-和-节点-的关系" class="headerlink" title="程序 和 节点 的关系"></a>程序 和 节点 的关系</h2><p>一个程序（对应一个main函数）里一般性跑一个节点，因为<code>spin</code>一个节点是阻塞线程的操作。当然你可以异步跑多个节点，但不常用。</p><h2 id="创建并运行一个功能包"><a href="#创建并运行一个功能包" class="headerlink" title="创建并运行一个功能包"></a>创建并运行一个功能包</h2><ol><li>使用如下命令在当前目录下创建一个ros2包：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ros2 pkg create &lt;包名&gt; --build-type ament_cmake --node-name &lt;程序名&gt; --dependencies &lt;依赖&gt;<br></code></pre></td></tr></table></figure><ul><li><code>ros2 pkg create</code>：创建包的 固定语法</li><li><code>--build-type</code>：构建包的选项，一般C++写<code>ament_cmake</code>，python写 <code>ament_python</code>。</li><li><code>--node-name</code>：可选参数，若指定将会默认添加一个<code>src/&lt;程序名&gt;.cpp</code>文件，并指定成程序名称。</li><li><code>--dependencies</code>：可选参数，添加依赖项，常见的依赖如<code>rclcpp</code>（ros2的c++接口）。</li></ul><p>下图为在ubuntu命令行创建一个名为<code>demo_cpp_pkg</code>的包的示例：</p><img src="/2025/06/11/ros2/image-20250611204247010.png" class="" title="image-20250611204247010"><p>一个包的基本结构：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift">demo_cpp_pkg<span class="hljs-operator">/</span><br><span class="hljs-operator">├──</span> <span class="hljs-type">CMakeLists</span>.txt           <span class="hljs-operator">←</span> 编译配置<br><span class="hljs-operator">├──</span> <span class="hljs-keyword">package</span>.xml              <span class="hljs-operator">←</span> 包元信息<br><span class="hljs-operator">├──</span> src<span class="hljs-operator">/</span>                     <span class="hljs-operator">←</span> 你自己写代码的地方<br><span class="hljs-operator">└──</span> include<span class="hljs-regexp">/demo_cpp_pkg/</span>    <span class="hljs-operator">←</span> （可选）头文件<br></code></pre></td></tr></table></figure><ol start="2"><li>新建<code>src/main.cpp</code>，写入如下基本节点代码：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;rclcpp/rclcpp.hpp&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> rclcpp;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    rclcpp::<span class="hljs-built_in">init</span>(argc, argv);<br>    <span class="hljs-keyword">auto</span> node = std::<span class="hljs-built_in">make_shared</span>&lt;Node&gt;(<span class="hljs-string">&quot;cpp_node&quot;</span>);<br>    <span class="hljs-built_in">RCLCPP_INFO</span>(node-&gt;<span class="hljs-built_in">get_logger</span>(), <span class="hljs-string">&quot;你好！C++节点&quot;</span>);<br>    rclcpp::<span class="hljs-built_in">spin</span>(node);<br>    rclcpp::<span class="hljs-built_in">shutdown</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>修改<code>CMakeLists.txt</code>成如下所示：</li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.8</span>)<br><span class="hljs-keyword">project</span>(demo_cpp_pkg)<br><br><span class="hljs-keyword">if</span>(CMAKE_COMPILER_IS_GNUCXX <span class="hljs-keyword">OR</span> CMAKE_CXX_COMPILER_ID <span class="hljs-keyword">MATCHES</span> <span class="hljs-string">&quot;Clang&quot;</span>)<br>  <span class="hljs-keyword">add_compile_options</span>(-Wall -Wextra -Wpedantic)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-comment"># find dependencies</span><br><span class="hljs-keyword">find_package</span>(ament_cmake REQUIRED)<br><span class="hljs-comment"># uncomment the following section in order to fill in</span><br><span class="hljs-comment"># further dependencies manually.</span><br><span class="hljs-comment"># 1. 查找rclcpp的头文件和库</span><br><span class="hljs-keyword">find_package</span>(rclcpp REQUIRED)<br><span class="hljs-comment"># 2. 添加可执行文件 main</span><br><span class="hljs-keyword">add_executable</span>(main src/main.cpp)<br><span class="hljs-comment"># 3. 为 main 添加依赖</span><br>ament_target_dependencies(<br>  main<br>  rclcpp<br>)<br><span class="hljs-comment"># 4. 将 main拷贝到 install目录</span><br><span class="hljs-keyword">install</span>(TARGETS<br>  main<br>  DESTINATION lib/<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>)<br><br><span class="hljs-keyword">if</span>(BUILD_TESTING)<br>  <span class="hljs-keyword">find_package</span>(ament_lint_auto REQUIRED)<br>  <span class="hljs-comment"># the following line skips the linter which checks for copyrights</span><br>  <span class="hljs-comment"># comment the line when a copyright and license is added to all source files</span><br>  <span class="hljs-keyword">set</span>(ament_cmake_copyright_FOUND <span class="hljs-keyword">TRUE</span>)<br>  <span class="hljs-comment"># the following line skips cpplint (only works in a git repo)</span><br>  <span class="hljs-comment"># comment the line when this package is in a git repo and when</span><br>  <span class="hljs-comment"># a copyright and license is added to all source files</span><br>  <span class="hljs-keyword">set</span>(ament_cmake_cpplint_FOUND <span class="hljs-keyword">TRUE</span>)<br>  ament_lint_auto_find_test_dependencies()<br><span class="hljs-keyword">endif</span>()<br><br>ament_package()<br><br></code></pre></td></tr></table></figure><p>其中：<code>ament_target_dependencies</code>函数是ament的扩展函数，等同于绑定依赖的include库和链接libraries，即下两行代码：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_include_directories</span>(main PUBLIC <span class="hljs-variable">$&#123;rclcpp_INCLUDE_DIRS&#125;</span>)<br><span class="hljs-keyword">target_link_libraries</span>(main <span class="hljs-variable">$&#123;rclcpp_LIBRARIES&#125;</span>)<br></code></pre></td></tr></table></figure><ol start="5"><li><p>使用cmake编译（vscode按下f7）。</p></li><li><p>使用colcon构建包：<code>colcon build</code></p></li><li><p><code>source install/setup/bash</code>。</p></li><li><p>运行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ros2 run &lt;包名&gt; &lt;程序名&gt;<br></code></pre></td></tr></table></figure><p>示例中即为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ros2 run demo_cpp_pkg main<br></code></pre></td></tr></table></figure></li></ol><h1 id="tf2"><a href="#tf2" class="headerlink" title="tf2"></a>tf2</h1><p>（坐标变换工具）</p><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><img src="/2025/06/11/ros2/image-20250628050334724.png" class="" title="image-20250628050334724"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 发布base_link到base_laser之间的变换</span><br>ros2 run tf2_ros static_transform_publisher --x 0.1 --y 0.0 --z 0.2 --roll 0.0 --pitch 0.0 --yaw 0.0 --frame-id base_link --child-frame-id base_laser<br><br><span class="hljs-comment"># 发布base_laser到wall_point之间的变换</span><br>ros2 run tf2_ros static_transform_publisher --x 0.3 --y 0.0 --z 0.0 --roll 0.0 --pitch 0.0 --yaw 0.0 --frame-id base_laser --child-frame-id wall_point<br><br><span class="hljs-comment"># 查询base_link 到wall_point之间的关系</span><br>ros2 run tf2_ros tf2_echo [source_frame] [target_frame]<br><span class="hljs-comment"># 即：</span><br>ros2 run tf2_ros tf2_echo base_link wall_point<br></code></pre></td></tr></table></figure><h1 id="urdf"><a href="#urdf" class="headerlink" title="urdf"></a>urdf</h1><p>(Unified Robot Description Format)</p><p>urdf是一种用于表示&#x2F;仿真机器人模型的XML格式。</p><p>下面是 <strong>URDF 中常见的标签</strong>及其作用简明总览，分为<strong>核心结构</strong>、<strong>几何与外观</strong>、<strong>运动与连接</strong>三大类：</p><hr><h2 id="一、核心结构标签"><a href="#一、核心结构标签" class="headerlink" title="一、核心结构标签"></a>一、核心结构标签</h2><table><thead><tr><th>标签</th><th>说明</th><th>示例&#x2F;备注</th></tr></thead><tbody><tr><td><code>&lt;robot&gt;</code></td><td>所有 URDF 的根标签，定义机器人名称</td><td><code>&lt;robot name=&quot;my_bot&quot;&gt;</code></td></tr><tr><td><code>&lt;link&gt;</code></td><td>描述一个部件（如一个刚体）</td><td>机器人上每个零件都需定义为一个 link</td></tr><tr><td><code>&lt;joint&gt;</code></td><td>描述两个 link 之间的连接关系</td><td>定义运动、旋转、固定等</td></tr></tbody></table><hr><h2 id="二、几何与外观标签（在-、、-中使用）"><a href="#二、几何与外观标签（在-、、-中使用）" class="headerlink" title="二、几何与外观标签（在 &lt;visual&gt;、&lt;collision&gt;、&lt;inertial&gt; 中使用）"></a>二、几何与外观标签（在 <code>&lt;visual&gt;</code>、<code>&lt;collision&gt;</code>、<code>&lt;inertial&gt;</code> 中使用）</h2><table><thead><tr><th>标签</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>&lt;visual&gt;</code></td><td>link 的可视化外观</td><td>RViz2 中展示用</td></tr><tr><td><code>&lt;collision&gt;</code></td><td>link 的碰撞体</td><td>用于仿真、碰撞检测</td></tr><tr><td><code>&lt;inertial&gt;</code></td><td>link 的惯性信息</td><td>包括质量、惯性矩、质心等</td></tr><tr><td><code>&lt;origin&gt;</code></td><td>坐标原点偏移，定义相对于父元素的位置和姿态</td><td><code>&lt;origin xyz=&quot;0 0 1&quot; rpy=&quot;0 0 0&quot;/&gt;</code></td></tr><tr><td><code>&lt;geometry&gt;</code></td><td>定义几何形状（与 <code>visual</code>、<code>collision</code> 配合）</td><td>包含 box、cylinder、sphere、mesh</td></tr><tr><td><code>&lt;box&gt;</code></td><td>长方体几何</td><td><code>&lt;box size=&quot;1 1 1&quot;/&gt;</code></td></tr><tr><td><code>&lt;cylinder&gt;</code></td><td>圆柱体几何</td><td><code>&lt;cylinder length=&quot;1&quot; radius=&quot;0.5&quot;/&gt;</code></td></tr><tr><td><code>&lt;sphere&gt;</code></td><td>球体几何</td><td><code>&lt;sphere radius=&quot;0.3&quot;/&gt;</code></td></tr><tr><td><code>&lt;mesh&gt;</code></td><td>加载外部模型文件（如 <code>.dae</code>, <code>.stl</code>）</td><td><code>&lt;mesh filename=&quot;package://path/model.dae&quot;/&gt;</code></td></tr><tr><td><code>&lt;material&gt;</code></td><td>材质颜色或纹理</td><td><code>&lt;material name=&quot;gray&quot;&gt;&lt;color rgba=&quot;0.5 0.5 0.5 1&quot;/&gt;&lt;/material&gt;</code></td></tr><tr><td><code>&lt;color&gt;</code></td><td>定义颜色值</td><td>RGBA 四维（透明度在最后）</td></tr></tbody></table><hr><h2 id="三、连接与运动标签（joint-内部）"><a href="#三、连接与运动标签（joint-内部）" class="headerlink" title="三、连接与运动标签（joint 内部）"></a>三、连接与运动标签（joint 内部）</h2><table><thead><tr><th>标签</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>&lt;parent&gt;</code></td><td>父 link 名称</td><td><code>&lt;parent link=&quot;base_link&quot;/&gt;</code></td></tr><tr><td><code>&lt;child&gt;</code></td><td>子 link 名称</td><td><code>&lt;child link=&quot;wheel_link&quot;/&gt;</code></td></tr><tr><td><code>&lt;axis&gt;</code></td><td>关节运动的轴向</td><td><code>&lt;axis xyz=&quot;0 0 1&quot;/&gt;</code> 表示绕 Z 轴</td></tr><tr><td><code>&lt;limit&gt;</code></td><td>关节限制（适用于 revolute&#x2F;prismatic）</td><td><code>&lt;limit lower=&quot;-1.57&quot; upper=&quot;1.57&quot; effort=&quot;1&quot; velocity=&quot;1&quot;/&gt;</code></td></tr><tr><td><code>&lt;dynamics&gt;</code></td><td>摩擦&#x2F;阻尼等动态参数</td><td>可选，增强仿真精度</td></tr><tr><td><code>&lt;type&gt;</code></td><td>关节类型</td><td><code>revolute</code>, <code>continuous</code>, <code>prismatic</code>, <code>fixed</code>, <code>floating</code>, <code>planar</code></td></tr></tbody></table><hr><h2 id="四、其它辅助标签（常用但非必须）"><a href="#四、其它辅助标签（常用但非必须）" class="headerlink" title="四、其它辅助标签（常用但非必须）"></a>四、其它辅助标签（常用但非必须）</h2><table><thead><tr><th>标签</th><th>用途</th><th>说明</th></tr></thead><tbody><tr><td><code>&lt;transmission&gt;</code></td><td>与控制器配合使用</td><td>在控制机器人时才需要</td></tr><tr><td><code>&lt;gazebo&gt;</code></td><td>Gazebo 特定配置（带插件）</td><td>与仿真配合用</td></tr><tr><td><code>&lt;xacro:macro&gt;</code></td><td>Xacro 宏定义</td><td>重复结构抽象</td></tr><tr><td><code>&lt;xacro:property&gt;</code></td><td>定义变量</td><td>用于参数传递或配置</td></tr></tbody></table><h1 id="xacro"><a href="#xacro" class="headerlink" title="xacro"></a>xacro</h1><p>(Xml Macro)</p><p>ROS还提供了用于简化urdf编写的xacro格式。文件后缀名<code>.xacro</code>。编写好文件后不能直接使用，应先转成urdf格式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装xacro包</span><br><span class="hljs-built_in">sudo</span> apt install ros-<span class="hljs-variable">$ROS_DISTRO</span>-xacro<br><br><span class="hljs-comment"># 转换成urdf</span><br>xacro &lt;macro文件名&gt;<br></code></pre></td></tr></table></figure><h1 id="在RViz中显示机器人"><a href="#在RViz中显示机器人" class="headerlink" title="在RViz中显示机器人"></a>在RViz中显示机器人</h1><p>当我们编写好urdf&#x2F;xacro机器人描述文件后，rviz并不能自动地去识别不同部件的坐标变换关系。实际上，urdf和rivz中间的桥梁是由<code>robot_state_publisher</code>包（和<code>joint_state_publisher</code>包）搭建起来的。</p><img src="/2025/06/11/ros2/robot_state_publisher.png" class=""><p>如上图的关系所示，<code>robot_state_publisher</code>包解析urdf中的tf变换关系。遇到静态tf（如定义为fixed的joint）通过<code>/tf_static</code>话题发布；遇到动态tf关系，先发布到<code>/robot_description</code>话题，另一边被<code>joint_state_publisher</code>包订阅，自动扫描动态的关节，并将其数值发布到<code>/joint_states</code>话题，最后<code>robot_state_publisher</code>包收到后，通过<code>/tf</code>话题发布。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>要想urdf加载进rviz，应该编写一个launch文件。在launch目录下新建一个<code>display.launch.py</code>，内容大致如下（大同小异，理解为主，切勿无脑照抄）：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> launch <span class="hljs-keyword">import</span> LaunchDescription<br><span class="hljs-keyword">from</span> launch_ros.actions <span class="hljs-keyword">import</span> Node<br><span class="hljs-keyword">from</span> launch.substitutions <span class="hljs-keyword">import</span> Command, FindExecutable<br><span class="hljs-keyword">from</span> ament_index_python.packages <span class="hljs-keyword">import</span> get_package_share_directory<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_launch_description</span>():<br>    <span class="hljs-comment"># 获取urdf路径</span><br>    urdf_file = os.path.join(<br>        get_package_share_directory(<span class="hljs-string">&quot;gimbal&quot;</span>),<br>        <span class="hljs-string">&quot;urdf&quot;</span>,<br>        <span class="hljs-string">&quot;gimbal.urdf.xacro&quot;</span><br>    ) <br><br>    <span class="hljs-comment"># xacro转urdf（通过xacro &lt;xacro文件路径&gt; 命令）</span><br>    urdf_content = Command([<br>        FindExecutable(name=<span class="hljs-string">&quot;xacro&quot;</span>),<br>        <span class="hljs-string">&quot; &quot;</span>,<br>        urdf_file<br>    ])<br><br>    <span class="hljs-keyword">return</span> LaunchDescription([<br>        <span class="hljs-comment"># robot_state_publisher节点</span><br>        Node(<br>            package=<span class="hljs-string">&quot;robot_state_publisher&quot;</span>,<br>            executable=<span class="hljs-string">&quot;robot_state_publisher&quot;</span>,<br>            parameters=[<br>                &#123; <span class="hljs-string">&quot;robot_description&quot;</span>: urdf_content &#125;<br>            ]<br>        ),<br>        <span class="hljs-comment"># joint_state_publisher节点</span><br>        Node(<br>            package=<span class="hljs-string">&quot;joint_state_publisher&quot;</span>,<br>            executable=<span class="hljs-string">&quot;joint_state_publisher&quot;</span><br>        ),<br>        <span class="hljs-comment"># RViz2节点</span><br>        Node(<br>            package=<span class="hljs-string">&quot;rviz2&quot;</span>,<br>            executable=<span class="hljs-string">&quot;rviz2&quot;</span>,<br>        )<br>    ])<br></code></pre></td></tr></table></figure><ol start="2"><li><p>修改CMakeLists.txt，添加<code>install</code>命令，部署目录</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># ...</span><br><br><span class="hljs-comment"># 将必要的目录（launch, urdf等）部署到share目录下</span><br><span class="hljs-keyword">install</span>(DIRECTORY<br>  launch<br>  urdf<br>  DESTINATION share/<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>/)<br><br><span class="hljs-comment"># ...</span><br></code></pre></td></tr></table></figure></li><li><p>编译并部署</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">colcon build<br><span class="hljs-built_in">source</span> install/setup.bash<br></code></pre></td></tr></table></figure></li><li><p>通过launch文件启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ros2 launch &lt;功能包名&gt; display.launch.py<br></code></pre></td></tr></table></figure><p>RViz将自动启动。</p></li><li><p>在RViz内进一步调整：</p><ol><li><p><code>Fixed Frame</code>默认为<code>world</code>，需要手动切换成你urdf的根部件（如<code>base_link</code>）</p></li><li><p>切换好以后很大概率<strong>机器人模型依旧加载不出来，只显示坐标轴</strong>。如下图：</p><img src="/2025/06/11/ros2/image-20250710155736756.png" class=""><p><strong>解决方法</strong>是：点开左下角Add - 添加RobotModel可视化 - 手动选择<code>Description Topic</code>下拉框中的<code>/robot_description</code>话题让rviz重新加载</p></li></ol></li></ol><h1 id="自定义消息类型XXX-msg"><a href="#自定义消息类型XXX-msg" class="headerlink" title="自定义消息类型XXX.msg"></a>自定义消息类型<code>XXX.msg</code></h1><p>ROS2中有许多内置的包，如<code>std_msgs</code>和 <code>geometry_msgs</code>，它们都有自己的消息类型用于节点间传输。当我们有这样的需求时也可自定义消息类型，步骤如下：</p><ol><li><p>自定义消息最好<strong>单开一个功能包</strong>存放，以便实现复用。当然如果你项目小的话挤在一个包里也行，看具体需求。这里我要声明装甲板相关的消息，因此创建一个叫<code>armor_interface</code>的包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ros2 pkg create armor_interface --build-type ament_cmake ...<br></code></pre></td></tr></table></figure></li><li><p>一个消息类型其实就是一个<code>XXX.msg</code>文件。在包目录下新建<code>msg</code>文件夹，添加下面两个文件：</p><ol><li><p><code>Armor.msg</code>：表示一个装甲板</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">string</span> <span class="hljs-keyword">name</span><br><span class="hljs-keyword">string</span> color<br><span class="hljs-keyword">string</span> <span class="hljs-keyword">type</span><br>geometry_msgs/Vector3 rvec<br>geometry_msgs/Pose pose<br></code></pre></td></tr></table></figure></li><li><p><code>Armors.msg</code>：表示多个装甲板的集合，用于传输</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">std_msgs/<span class="hljs-selector-tag">Header</span> <span class="hljs-selector-tag">header</span><br>Armor<span class="hljs-selector-attr">[]</span> data<br></code></pre></td></tr></table></figure></li></ol></li><li><p>修改CMakeLists.txt：</p><ol><li><p>添加必要的包</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">find_package</span>(rosidl_default_generators REQUIRED)  <span class="hljs-comment"># 编译器自动识别msg文件并编译成代码</span><br><span class="hljs-keyword">find_package</span>(std_msgs REQUIRED)<br><span class="hljs-keyword">find_package</span>(geometry_msgs REQUIRED)<br></code></pre></td></tr></table></figure></li><li><p>生成自定义消息的CMake命令 <code>rosidl_generate_interfaces</code>：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake">rosidl_generate_interfaces(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span><br>  <span class="hljs-string">&quot;msg/Armor.msg&quot;</span><br>  <span class="hljs-string">&quot;msg/Armors.msg&quot;</span><br>  <br>  DEPENDENCIES <br>    std_msgs <br>    geometry_msgs<br>)<br></code></pre></td></tr></table></figure></li></ol></li><li><p>修改<code>package.xml</code>：</p><p>往<code>package.xml</code>添加一行（不然不给编译）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">   <span class="hljs-tag">&lt;<span class="hljs-name">member_of_group</span>&gt;</span>rosidl_interface_packages<span class="hljs-tag">&lt;/<span class="hljs-name">member_of_group</span>&gt;</span><br><br>5. 编译&amp;部署包<br><br>   ```bash<br>   colcon build<br>   source install/setup.bash<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>vscode IntelliSense找不到包的解决方法</title>
    <link href="/2025/06/10/vscode-IntelliSense%E6%89%BE%E4%B8%8D%E5%88%B0%E5%8C%85%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <url>/2025/06/10/vscode-IntelliSense%E6%89%BE%E4%B8%8D%E5%88%B0%E5%8C%85%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>在用vscode写ros2项目时，势必会有引用rclcpp库这一步。一般只需在<code>CMakeLists.txt</code>中写好引用rclcpp的相关代码即可顺利编译：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake">...<br><br><span class="hljs-keyword">find_package</span>(rclcpp REQUIRED)<br><span class="hljs-keyword">target_include_directories</span>(main PUBLIC <span class="hljs-variable">$&#123;rclcpp_INCLUDE_DIRS&#125;</span>)<br><span class="hljs-keyword">target_link_libraries</span>(main <span class="hljs-variable">$&#123;rclcpp_LIBRARIES&#125;</span>)<br></code></pre></td></tr></table></figure><p>但这也仅仅是能编译成功，我们还想要vscode的C&#x2F;C++插件IntelliSense智能提示能识别我们引入的库，提高我们代码效率。而常常在这里vscode不能很顺利地识别，需要我们手动地配置。</p><h1 id="问题阐述"><a href="#问题阐述" class="headerlink" title="问题阐述"></a>问题阐述</h1><p>很常见的情况是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;rclcpp/rclcpp.hpp&quot;</span>  <span class="hljs-comment">// vsc在这一行报错</span></span><br><br>...<br></code></pre></td></tr></table></figure><p>并且智能提示识别不了rclcpp命名空间下的任何函数……</p><p>下为实景图：</p><img src="/2025/06/10/vscode-IntelliSense%E6%89%BE%E4%B8%8D%E5%88%B0%E5%8C%85%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/image-20250610163143830.png" class="" title="image-20250610163143830"><img src="/2025/06/10/vscode-IntelliSense%E6%89%BE%E4%B8%8D%E5%88%B0%E5%8C%85%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/image-20250610163224915.png" class="" title="image-20250610163224915"><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><ol><li><p>配置C&#x2F;C++扩展包：<code>Ctrl+Shift+P</code>打开命令面板 &gt; 找到<code>C/C++: Edit Configurations(UI)</code></p><img src="/2025/06/10/vscode-IntelliSense%E6%89%BE%E4%B8%8D%E5%88%B0%E5%8C%85%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/image-20250610163722314.png" class="" title="image-20250610163722314"><p>在<code>IncludePath</code>栏中添加你的包的路径（我这里是ros2下的rclcpp，包含文件位于<code>/opt/ros/humble/include/rclcpp</code>，但为了省事我把整个<code>include</code>文件夹都包括了）：</p><img src="/2025/06/10/vscode-IntelliSense%E6%89%BE%E4%B8%8D%E5%88%B0%E5%8C%85%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/image-20250610164114921.png" class="" title="image-20250610164114921"></li><li><p>删除<code>.vscode/c_cpp_properties.json</code>的<code>configurationProvider</code>属性。</p><img src="/2025/06/10/vscode-IntelliSense%E6%89%BE%E4%B8%8D%E5%88%B0%E5%8C%85%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/Snipaste_2025-06-10_15-57-42.png" class="" title="Snipaste_2025-06-10_15-57-42"><p>注意<strong>删完重启vscode</strong>！这一步挺关键的。</p></li><li><p>同理，任意的包只要你知道其安装路径，把它添加进上述includePath中，vscode的智能提示就能重新激活了。如opencv2库在<code>/usr/include/opencv4/**</code>下。</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rm校赛2025</title>
    <link href="/2025/05/28/rm%E6%A0%A1%E8%B5%9B2025/"/>
    <url>/2025/05/28/rm%E6%A0%A1%E8%B5%9B2025/</url>
    
    <content type="html"><![CDATA[<h1 id="赛规回顾"><a href="#赛规回顾" class="headerlink" title="赛规回顾"></a>赛规回顾</h1><p>主办方提供一个usb摄像头、一张视觉识别标签。选手需要将摄像头连接电脑，捕捉视觉标签并加以识别。识别结果决定了同队的机器人往哪边的（左&#x2F;右）核心区发送弹丸。</p><h2 id="视觉标签"><a href="#视觉标签" class="headerlink" title="视觉标签"></a>视觉标签</h2><p>视觉识别标签主要有以下几个部分构成：定位方块、指示方块、指向三角形。其中<strong>指向三角形与指示方块颜色一致代码这一标签指示的方向是正确的，反之为错误的</strong>。 视觉标识尺寸为 150*150，材质为 A4 纸彩印，视觉识别标签的具体图形如下：</p><p>右方向正确标签：</p><img src="/2025/05/28/rm%E6%A0%A1%E8%B5%9B2025/right-c.png" class=""><p>左方向正确标签：</p><img src="/2025/05/28/rm%E6%A0%A1%E8%B5%9B2025/left-c.png" class=""><p>右方向错误标签：</p><img src="/2025/05/28/rm%E6%A0%A1%E8%B5%9B2025/right-inc.png" class=""><p>左方向错误标签：</p><img src="/2025/05/28/rm%E6%A0%A1%E8%B5%9B2025/left-inc.png" class=""><blockquote><p>Tips： 若参赛双方均不参加视觉侦查挑战，则跳过该阶段，直接进入对抗阶段。 </p><p>视觉计算平台获取到标识信息后，对其进行处理，若为错误标识，则错误标识 所示方向的另一方为正确标识；若为正确标识，则标识所示方向即为正确方向。 </p><p>视觉侦查挑战的成功与否由黄色弹丸在该阶段结束后的位置正确与否进行判断，以下例举几个情景: </p><p>a. 抽中左方错误标识，机器人向右方核心区投射弹丸，并且弹丸成功进入对 方右侧核心区，判定为挑战成功； </p><p>b. 抽中右方正确标识，机器人向右方核心区投射弹丸，但机器人未投射或投 射弹丸未进入对方右侧核心区，则判定为挑战失败。</p></blockquote><p>**简单来说，如果中间的方块与三角形同色，则方向为三角形指向；异色，则为三角形指向的反向。**不管标签正确与否，最终都需要给下位机发送一个方向&#x2F; 角度数据。</p><h2 id="USB摄像头"><a href="#USB摄像头" class="headerlink" title="USB摄像头"></a>USB摄像头</h2><h1 id="识别思路"><a href="#识别思路" class="headerlink" title="识别思路"></a>识别思路</h1><ol><li>识别三个定位块（如必要按左上、右上、右下的顺序做透视变换）<ol><li>对摄像机拍摄到的整个画面roi处理，聚焦于我们感兴趣的视觉标签。</li><li>根据某些算法依次找到三个定位块，并计算其宽高、中心点、角度误差等数据。</li><li>捏住三个中心点，做透视变换，把（潜在可能倒着、斜着放的）图片回正，并再次roi，即可聚焦于标签中央区域。</li></ol></li><li>对中间的指向块、三角形，比较它们的平均hsv值，若相差较大即可判为异色；否则同色。</li><li>根据指向三角形的三个顶点和直角方向判断最终指向。</li></ol><h1 id="实操记录"><a href="#实操记录" class="headerlink" title="实操记录"></a>实操记录</h1><ul><li><p>一开始觉得这跟识别二维码蛮像的，因为都有三个定位方块。于是试图找现成识别二维码的源码。结果发现在opencv里已经被封装成一个类了 <code>QRCodeDetector</code>，源码太长太臭，看不懂。</p></li><li><p>看的同济<em>TJ-SuperPower战队</em> 视觉培训（BV1dGHZeiEi2）快速认识了一下ubuntu、cmake和opencv，主要是opencv。了解了识别装甲板的最简化流程：读入 &gt; bgr转灰度 &gt; threshold二值化 &gt; findContours找轮廓点 &gt; minAreaRect轮廓点最小外接矩形 &gt; 识别出两个灯条 &gt; 中间的白色数字交给深度学习解决。</p></li><li><p>主播第一步先是识别了静态的视觉标签。</p><ul><li><p>此时判断异色的逻辑还是：分别用红色、蓝色的两个mask掩码原图，这样就有了两张红蓝掩码图，如果这两张图上各存在一个轮廓，判异色；如果只有一张有轮廓，另一张没有，判同色。但在实际的摄像头下，这种方法行不通，一是红、蓝色的hue范围具体是多少无法得知；二是用“掩码图上有无轮廓”作为依据实在简陋。</p></li><li><p>第一版没有用到<code>minAreaRect</code>函数勾画外接矩形，而是全程使用<code>approxPolyDP</code>拟合形状。不知道两者孰优孰劣</p></li><li><p>第一版没有意识到错误的标签其实是指向反向的，因此遇到错误标签会直接输出“Incorrect image”。</p></li><li><p>代码在项目的<code>main2.cpp</code>中。如果要编译，可将<code>CMakeLists.txt</code>中</p></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_executable</span>(main main.cpp ...<br></code></pre></td></tr></table></figure><p>​    这一行的<code>main.cpp</code>改成<code>main2.cpp</code>。</p></li><li><p>自从主播到了场地，形势便又发生了变化。面临的困难有：a. 需要熟悉usb摄像头 b. 实际标签上安装了灯管，但捕获的图像不经过处理根本亮的看不清 c. 拍摄的图像远不及原图清晰 d. 需要熟悉串口通信发送端的任务</p><ul><li><p>对于usb摄像头，以下是一些常用操作记录（虚拟机版本 vmware ubuntu22.04.5）：</p><ul><li><p>列出本机连接的摄像头设备（一般本机内置摄像头是&#x2F;dev&#x2F;video0，但奇怪 主播的usb摄像头反而是这个）</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">ls /dev/video*<br></code></pre></td></tr></table></figure></li><li><p>使用cheese摄像头软件捕获（需事先安装包<code>sudo apt install cheese</code>）</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">cheese<br></code></pre></td></tr></table></figure></li><li><p>使用ffplay捕获（需事先安装包<code>sudo apt install ffmpeg</code>）</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">ffplay /dev/videoX<br></code></pre></td></tr></table></figure></li><li><p>使用 guvcview捕获（需事先安装包<code>sudo apt install guvcview</code>）</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">guvcview<br></code></pre></td></tr></table></figure></li><li><p>使用 v4l-utils查看视频参数等（需事先安装包<code>sudo apt install v4l-utils</code>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">v4l2-ctl --list-devices      <span class="hljs-comment"># 列出所有摄像头设备</span><br>v4l2-ctl --list-formats-ext  <span class="hljs-comment"># 查看摄像头设备支持的格式</span><br>v4l2-ctl -d /dev/videoX -l   <span class="hljs-comment"># 查看指定设备的参数</span><br>v4l2-ctl -d /dev/videoX --set-ctrl=&lt;参数名&gt;=&lt;值&gt;   <span class="hljs-comment"># 设置指定设备的指定参数值</span><br>v4l2-ctl -d /dev/videoX --get-ctrl=&lt;参数名&gt;        <span class="hljs-comment"># 查看指定设备的指定参数值</span><br></code></pre></td></tr></table></figure></li></ul><p>熟悉了连接linux机等操作后，主播却发现捕获的图像始终都不能正常显示，乱码，如下：</p><video src="./rm校赛2025/36896e3395d2a1bd917316989d85853a.mp4" /><p>不止guvcview，cheese和ffmpeg也不管用。淘宝客服也不造。瞎折腾了一番，最终主播发现 <strong>把虚拟机usb协议改成3.1</strong>有用（默认是usb2.0，但是摄像头参数上明写着usb2.0，挠头）：</p><img src="/2025/05/28/rm%E6%A0%A1%E8%B5%9B2025/usb.png" class=""></li><li><p>下一个挑战是灯光导致的过曝问题。可通过调节相机曝光度解决，首先需要关闭自动曝光，再调节具体的值。以下是两种方法：</p><ul><li><p>法一：图形化界面<code>guvcview</code></p><img src="/2025/05/28/rm%E6%A0%A1%E8%B5%9B2025/guvcview.jpg" class=""><p>摄像机不在身边，找了张网图，曝光在 <code>Image Controls &gt; 拉到最底下 exposure相关的条目</code>。</p></li><li><p>法二：命令行工具<code>v4l-utils</code></p><p>先查看参数，记住自动曝光和曝光值的参数名称</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">v4l2-ctl -d /dev/video0 -l<br></code></pre></td></tr></table></figure><p>显示如下，名字可能不同</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ...</span><br>exposure_auto (menu) : min=0 max=3 default=3 value=3<br>                       0: Manual Mode<br>                       1: Auto Mode<br>exposure_absolute (int) : min=5 max=5000 value=313 step=1<br><span class="hljs-comment"># ...</span><br></code></pre></td></tr></table></figure><p>再设置值，关闭自动曝光（3改成1）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">v4l2-ctl -d /dev/video0 --set-ctrl=exposure_auto=1<br></code></pre></td></tr></table></figure><p>调节曝光度值（实际默认值为313，主播调到了100以下，大约在80~100这个范围）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">v4l2-ctl -d /dev/video0 --set-ctrl=exposure_absolute=90<br></code></pre></td></tr></table></figure></li></ul></li><li><p>以及实际拍摄质量远比原图恶劣的问题。解决思路是尽量不依靠具体值（如：方块面积、宽高，颜色等），而是依靠多个元素之间的关系，放在代码中表现在：</p><ul><li>定位方块是正方形，宽高比应在容忍值之内（.2）。</li><li>三个定位方块应大小一致，取宽度比较应在容忍值内。</li><li>三个定位方块的倾斜角度应一致，取两两夹角应在容忍值内（5°）。</li><li>三个定位方块的中心应构成一个等腰直角三角形。这点很重要。</li><li>指向方块和三角形的mean hsv应大致相似，在容忍值内。</li><li>……</li></ul></li><li><p>串口通信主机发送的任务。主播从电控组那儿拿到一个usb串口模块，以及机械组说只需要发送一个方向信息，角度他们已经提前计算好了，倒省了不少力气。最终代码在<code>tasks/serialsender.cpp</code>中。</p></li></ul></li></ul><h1 id="程序参数"><a href="#程序参数" class="headerlink" title="程序参数"></a>程序参数</h1><ul><li><p>虚拟机环境：vmware Ubuntu22.04.5</p></li><li><p>编译环境：vscode 1.99.3, g++ (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0, OpenCV 4.5.4, cmake 3.22.1</p></li><li><p>编译方法</p><ol><li><code>ctrl+shift+P</code>调出命令面板，选择 CMake:Configure，再选择g++编译</li><li>f7编译</li><li>运行 <code>./build/main [参数1] [参数2] ...</code></li></ol></li><li><p>运行截图</p><img src="/2025/05/28/rm%E6%A0%A1%E8%B5%9B2025/image-20250528221946239.png" class=""><img src="/2025/05/28/rm%E6%A0%A1%E8%B5%9B2025/image-20250528222116653.png" class=""></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>gmp</title>
    <link href="/2025/05/27/gmp/"/>
    <url>/2025/05/27/gmp/</url>
    
    <content type="html"><![CDATA[<h1 id="GMP大数库"><a href="#GMP大数库" class="headerlink" title="GMP大数库"></a>GMP大数库</h1><p><em>（<a href="https://gmplib.org/%EF%BC%89">https://gmplib.org/）</a></em></p><h1 id="大整数（mpz-t）"><a href="#大整数（mpz-t）" class="headerlink" title="大整数（mpz_t）"></a>大整数（<code>mpz_t</code>）</h1><h2 id="储存方式"><a href="#储存方式" class="headerlink" title="储存方式"></a>储存方式</h2><p>使用“字”（limb）数组来模拟大数。GMP 不使用字符串或高层封装来表示大数，而是<strong>模拟 CPU 的“低位字”运算</strong>，直接操作无符号整型数组，效率极高。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-type">int</span> _mp_alloc;     <span class="hljs-comment">// 分配了多少个 limb（内存块）</span><br>  <span class="hljs-type">int</span> _mp_size;      <span class="hljs-comment">// 实际使用的 limb 个数（正负表示符号）</span><br>  <span class="hljs-type">mp_limb_t</span> *_mp_d;  <span class="hljs-comment">// 指向 limb 数组的指针</span><br>&#125; __mpz_struct;<br><br><span class="hljs-keyword">typedef</span> __mpz_struct <span class="hljs-type">mpz_t</span>[<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><code>mp_limb_t</code> 是一个无符号整型，通常是 <code>unsigned long</code>（32 或 64 位，依 CPU 架构而定）。</li><li>整数以**低位在前（小端）**的方式存储在 <code>_mp_d</code> 指向的数组中。</li></ul><h2 id="运行时动态扩容机制"><a href="#运行时动态扩容机制" class="headerlink" title="运行时动态扩容机制"></a>运行时动态扩容机制</h2><p>GMP 在执行运算（如加法、乘法、左移）时，会自动检查当前 <code>_mp_alloc</code> 是否足够。如果不够用，GMP 会调用内部的 <code>_mpz_realloc()</code> 或相关函数来<strong>重新分配更大的 limb 数组</strong>。</p><p>在 GMP 源码中，<strong>扩容主要由宏&#x2F;函数 <code>MPZ_REALLOC</code> 或 <code>_mpz_realloc</code> 实现</strong>，它们在以下场景被调用：</p><ul><li>目标变量 limb 数量不足</li><li>当前操作将产生更大的结果（如进位）</li><li>乘法结果位数大于任一操作数</li></ul><h2 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h2><p>原理见<code>mpn/mul_n.c</code>，大致思路是根据limb个数而采用不同的算法。</p><ul><li><code>BELOW_THRESHOLD (n, MUL_TOOM22_THRESHOLD)</code>时，使用<code>mul_basecase</code>算法。</li><li><code>BELOW_THRESHOLD (n, MUL_TOOM33_THRESHOLD)</code>时，使用<code>mpn_toom22_mul</code>算法。</li><li><code>BELOW_THRESHOLD (n, MUL_TOOM44_THRESHOLD)</code>时，使用<code>mpn_toom33_mul</code>算法。</li><li><code>BELOW_THRESHOLD (n, MUL_TOOM6H_THRESHOLD)</code>时，使用<code>mpn_toom44_mul</code>算法.</li><li><code>BELOW_THRESHOLD (n, MUL_TOOM8H_THRESHOLD)</code>时，使用<code>mpn_toom6h_mul</code>算法。</li><li><code>BELOW_THRESHOLD (n, MUL_FFT_THRESHOLD)</code>时，使用<code>mpn_toom8h_mul</code>算法。</li><li>否则最终使用<code>mpn_fft_mul</code>算法。</li><li>这些阈值是编译时或运行时通过性能基准（tune）测量决定的。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>opencv</title>
    <link href="/2025/05/14/opencv/"/>
    <url>/2025/05/14/opencv/</url>
    
    <content type="html"><![CDATA[<h1 id="通过进行像素算术运算改变图像亮度"><a href="#通过进行像素算术运算改变图像亮度" class="headerlink" title="通过进行像素算术运算改变图像亮度"></a>通过进行像素算术运算改变图像亮度</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> cv;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Mat src = <span class="hljs-built_in">imread</span>(<span class="hljs-string">&quot;...&quot;</span>);<br>    Mat dst;<br>    <span class="hljs-built_in">add</span>(src, <span class="hljs-built_in">Scalar</span>(<span class="hljs-number">50</span>,<span class="hljs-number">50</span>,<span class="hljs-number">50</span>), dst);  <span class="hljs-comment">// 相当于对每个像素点的bgr各加50</span><br><span class="hljs-comment">// subtract(src, Scalar(50, 50, 50), dst);  // 相当于对每个像素点的bgr各减50</span><br><span class="hljs-comment">// multiply(src, Scalar(2, 2, 2), dst);   // 相当于对每个像素点的bgr各乘以2</span><br><span class="hljs-comment">// divide(src, Scalar(2, 2, 2), dst);   // 相当于对每个像素点的bgr各除以2</span><br>    <br>    <span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;dst&quot;</span>, dst);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>add()</code>和<code>subtract()</code>增加，理解为向白色255靠近，所以更亮；</p><p><code>subtract()</code>和<code>divide()</code>减少，理解为向黑色0靠近，所以更暗。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>虚拟机配置git代理</title>
    <link href="/2025/04/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/"/>
    <url>/2025/04/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="虚拟机配置代理"><a href="#虚拟机配置代理" class="headerlink" title="虚拟机配置代理"></a>虚拟机配置代理</h1><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p>把玩我的虚拟机时发现竟然无法用<code>git clone</code>命令</p><blockquote><p>fatal: unable to access ‘<a href="https://github.com/P-Chao/QRCode-CV4.git/">https://github.com/P-Chao/QRCode-CV4.git/</a>‘: Failed to connect to github.com port 443 after 10 ms: Connection refused</p></blockquote><p>于是我用了以下步骤解决：</p><ol><li><p>宿主机是windows，装有clash for windows；虚拟机是vmware上创建的 ubuntu22.04。</p></li><li><p>首先，检查你的clash端口（一般是7890 不用改），再将“允许局域网接入clash”打开。</p><img src="/2025/04/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/image-20250423022044022.png" class=""><ol start="3"><li><p>转到ubuntu上，设置git的全局http&#x2F;https代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global http.proxy http://192.168.x.x:7890<br>git config --global https.proxy http://192.168.x.x:7890<br></code></pre></td></tr></table></figure><p>其中<code>192.168.x.x</code>是宿主机的ip地址，<code>7890</code>是clash的端口号。</p><p>不知道ip地址怎么办？终端输入<code>ipconfig</code>，就能查到了。如下图：</p><img src="/2025/04/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/image-20250423022409281.png" class=""></li><li><p>配置完，便可愉快地使用<code>git clone</code>啦！</p><img src="/2025/04/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/image-20250423022712139.png" class="" title="image-20250423022712139"></li></ol></li></ol><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><ol><li><p>需要的工具：vmware、虚拟机、梯子（我的clash for windows）</p></li><li><p>配置梯子：</p><img src="/2025/04/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/cfw.png" class=""><ol><li>记住cfw的端口号，默认<code>7890</code>无需更改，一会儿要填在虚拟机中。</li><li>开启<code>允许局域网接入Clash</code>。</li><li>开启<code>服务模式</code>，如第一次使用，需要额外安装。</li><li>开启<code>TUN模式</code>，需要先开启服务模式。</li><li>至此，梯子部分已配置完成。</li></ol></li><li><p>配置虚拟机（我用的Ubuntu 22.04）</p><ol><li>虚拟机设置 - 网络适配器 - 勾选 <code>NAT模式</code>，应用完可能需要重启虚拟机生效。</li></ol><img src="/2025/04/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/image-20250527223353382.png" class=""><ol start="2"><li><p>宿主机终端输入<code>ipconfig</code>查看本机ip地址（参考图见上）。记住<code>无线局域网适配器 WLAN</code>的ipv4（但是网上有说<code>VMware Network Adapter VMnet8</code>的）。</p></li><li><p>ubuntu设置界面 - 网络 - 网络代理，改为手动，将框出来的代理条目：前一栏设置成刚才的ipv4地址，后一栏设置成cfw的端口号（<code>7890</code>）。</p><img src="/2025/04/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/image-20250527224404764.png" class="" title="image-20250527224404764"></li></ol></li><li><p>全部设置完试着ping一下网址 <code>ping google.com</code> 确保成功。</p></li><li><p>至此，你的虚拟机就可以科学上网了！</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>代码随想录</title>
    <link href="/2025/03/21/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    <url>/2025/03/21/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>定义：一种利用特殊值直接访问数据的数据结构。</p><p>★ 使用场景：判断某个值是否出现在集合中&#x2F; 出现过。</p><p>拿空间换时间。时间复杂度：普通暴力寻找：O(n)，哈希法：O(1)</p><p>哈希函数？</p><p>哈希碰撞？</p><p>hashcode？</p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><ul><li><p><code>std::reverse()</code>的范围是<strong>左开右闭 [first, last)</strong>，想要翻转第8个字符到第12个字符的话，应写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">std:<span class="hljs-built_in">reverse</span>(str.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">7</span>,    <span class="hljs-comment">// 第8个字符下标为7 </span><br>            str.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">12</span>);  <span class="hljs-comment">// 第12个字符下标为11，但右闭需要向后移一格</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><h2 id="公共接口"><a href="#公共接口" class="headerlink" title="公共接口"></a>公共接口</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss">命名空间：std<br>头文件：&lt;vector&gt;<br><br>bool <span class="hljs-built_in">empty</span>();<br>void <span class="hljs-built_in">push_back</span>(...);  <span class="hljs-comment">// 向最后添加元素</span><br>T <span class="hljs-built_in">at</span>(int i);          <span class="hljs-comment">// 返回下标为i的元素</span><br>operator<span class="hljs-selector-attr">[]</span>(int i);    <span class="hljs-comment">// 索引器，同at()</span><br>void <span class="hljs-built_in">insert</span>(...); <span class="hljs-comment">// 添加元素</span><br>??? <span class="hljs-built_in">find</span>(...);   <span class="hljs-comment">// 查找元素，一般用法：if (set.find(val) != set.end())  // 则找到</span><br>void <span class="hljs-attribute">clear</span>();    <span class="hljs-comment">// 清空</span><br>??? <span class="hljs-built_in">begin</span>();     <span class="hljs-comment">// 返回指向第一个元素的迭代器</span><br>??? <span class="hljs-built_in">end</span>();       <span class="hljs-comment">// 返回指向最后一个元素**再下一个元素的**迭代器</span><br>int <span class="hljs-built_in">size</span>();      <span class="hljs-comment">// 元素个数</span><br></code></pre></td></tr></table></figure><h1 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h1><h2 id="公共接口-1"><a href="#公共接口-1" class="headerlink" title="公共接口"></a>公共接口</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss">命名空间：std<br>头文件：&lt;unordered_set&gt;<br><br>bool <span class="hljs-built_in">empty</span>();<br>void <span class="hljs-built_in">insert</span>(...); <span class="hljs-comment">// 添加元素</span><br>??? <span class="hljs-built_in">find</span>(...);   <span class="hljs-comment">// 查找元素，一般用法：if (set.find(val) != set.end())  // 则找到</span><br>void <span class="hljs-attribute">clear</span>();    <span class="hljs-comment">// 清空</span><br>??? <span class="hljs-built_in">begin</span>();     <span class="hljs-comment">// 略，见上</span><br>??? <span class="hljs-built_in">end</span>();       <span class="hljs-comment">// 略，见上</span><br>int <span class="hljs-built_in">size</span>();      <span class="hljs-comment">// 元素个数</span><br></code></pre></td></tr></table></figure><h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><h1 id="STL实现"><a href="#STL实现" class="headerlink" title="STL实现"></a>STL实现</h1><p>STL（Standard Template Library）有三个常见的版本：</p><ol><li>第一个C++ STL实现：HP STL，开源</li><li>Visual C++编译器使用：P.J.Plauger STL，闭源，蓝本是HP STL</li><li>Linux的GCC编译器使用：SGI STL，开源易读，蓝本还是HP STL，由美国硅图公司（Silicon Graphics Computer System）实现。</li></ol><h1 id="cpp的stack容器"><a href="#cpp的stack容器" class="headerlink" title="cpp的stack容器"></a>cpp的stack容器</h1><h2 id="公共接口-2"><a href="#公共接口-2" class="headerlink" title="公共接口"></a>公共接口</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp">命名空间：std<br>头文件：&lt;stack&gt;<br><br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">empty</span>()</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span>()</span>;   <span class="hljs-comment">// 无返回值！</span><br><span class="hljs-function">T <span class="hljs-title">top</span>()</span>;      <span class="hljs-comment">// 返回栈顶元素。如果此时栈为空，则程序崩溃</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span>()</span>;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">size</span>()</span>;<br></code></pre></td></tr></table></figure><h1 id="cpp的queue容器"><a href="#cpp的queue容器" class="headerlink" title="cpp的queue容器"></a>cpp的queue容器</h1><h2 id="公共接口-3"><a href="#公共接口-3" class="headerlink" title="公共接口"></a>公共接口</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp">命名空间：std<br>头文件：&lt;queue&gt;<br><br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">empty</span>()</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span>()</span>;   <span class="hljs-comment">// 无返回值！</span><br><span class="hljs-function">T <span class="hljs-title">front</span>()</span>;  <span class="hljs-comment">// 返回队列中最旧的元素，即：最后一个元素</span><br><span class="hljs-function">T <span class="hljs-title">back</span>()</span>;   <span class="hljs-comment">// 返回队列中最新的元素，即：第一个元素</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span>()</span>;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">size</span>()</span>;<br></code></pre></td></tr></table></figure><h1 id="lc1047-重复项删除"><a href="#lc1047-重复项删除" class="headerlink" title="lc1047. 重复项删除"></a>lc1047. 重复项删除</h1><p>题目本身没什么好讲的，拿一个栈遍历字符串秒了。这道题可以让人联想到消消乐。值得讲的是一些数据结构操作的细节：</p><ol><li><p>如何将一个<code>stack</code>中的字符放入一个<code>string</code>中？第一版代码（我写的）如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">ret</span><span class="hljs-params">(s.length(), <span class="hljs-string">&#x27;\0&#x27;</span>)</span></span>;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>())<br>&#123;<br>ret[i++] = st.<span class="hljs-built_in">top</span>();<br>st.<span class="hljs-built_in">pop</span>();<br>&#125;<br>ret.<span class="hljs-built_in">resize</span>(i);<span class="hljs-comment">// 再resize</span><br><span class="hljs-built_in">reverse</span>(ret.<span class="hljs-built_in">begin</span>(), ret.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 最后翻转，因为是stack</span><br><span class="hljs-keyword">return</span> ret;<br></code></pre></td></tr></table></figure><p>第二版（看了代码随想录）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string ret = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>())<br>&#123;<br>    ret += st.<span class="hljs-built_in">top</span>();   <span class="hljs-comment">// c++的string重载了+= ，方便很多</span><br>    st.<span class="hljs-built_in">pop</span>();<br>&#125;<br><span class="hljs-built_in">reverse</span>(ret.<span class="hljs-built_in">begin</span>(), ret.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 这里就不用resize了，仅仅翻转就好</span><br><span class="hljs-keyword">return</span> ret;<br></code></pre></td></tr></table></figure><p>★★★ 第三版（string直接作为栈来用）★★★</p><p>其中：</p><ol><li><code>back()</code>: 返回最后一个字符。对应的是<code>front()</code>返回第一个字符。</li><li><code>push_back(...)</code>: 往字符串末尾田间一个字符。</li><li><code>pop_back()</code>: 弹出字符串最后一个字符。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 下面是完整的本题代码！</span><br>string ret;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : s)<br>&#123;<br>    <span class="hljs-keyword">if</span> (!ret.<span class="hljs-built_in">empty</span>()<br>       &amp;&amp; ret.<span class="hljs-built_in">back</span>() == ch)<br>        ret.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">else</span><br>        ret.<span class="hljs-built_in">push_back</span>(ch);<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br></code></pre></td></tr></table></figure></li></ol><h1 id="lc347-前K个高频元素"><a href="#lc347-前K个高频元素" class="headerlink" title="lc347. 前K个高频元素"></a>lc347. 前K个高频元素</h1><p>模板题：给定一个无序数组，要求返回其中出现次数前K多（&#x2F;少）的元素。</p><p>利用<strong>优先队列</strong>（priority_queue）解题。优先队列涉及到堆（Heap）的概念：</p><img src="/2025/03/21/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250407235723.jpg" class=""><img src="/2025/03/21/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20250407235651.jpg" class=""><img src="/2025/03/21/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/IMG_3609.JPG" class=""><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><img src="/2025/03/21/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/IMG_3610.JPG" class=""><img src="/2025/03/21/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/IMG_3611.JPG" class="">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>apk签名校验</title>
    <link href="/2025/03/05/apk%E7%AD%BE%E5%90%8D%E6%A0%A1%E9%AA%8C/"/>
    <url>/2025/03/05/apk%E7%AD%BE%E5%90%8D%E6%A0%A1%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="apk签名"><a href="#apk签名" class="headerlink" title="apk签名"></a>apk签名</h1><p>通过对 Apk 进行签名，开发者可以证明对 Apk 的所有权和控制权，可用于安装和更新其应用。而在 Android 设备上的安装 Apk ，如果是一个没有被签名的 Apk，则会被拒绝安装。在安装 Apk 的时候，软件包管理器也会验证 Apk 是否已经被正确签名，并且通过签名证书和数据摘要验证是否合法没有被篡改。只有确认安全无篡改的情况下，才允许安装在设备上。</p><p>简单来说，APK 的签名主要作用有两个：</p><ol><li>证明 APK 的所有者。</li><li>允许 Android 市场和设备校验 APK 的正确性。</li></ol><p>Android 目前支持以下四种应用签名方案：</p><ul><li>v1 方案：基于 JAR 签名。</li><li>v2 方案：APK 签名方案 v2（在 Android 7.0 中引入）</li><li>v3 方案：APK 签名方案 v3（在 Android 9 中引入）</li><li>v4 方案：APK 签名方案 v4（在 Android 11 中引入）</li></ul><p>V1 签名的机制主要就在 <code>META-INF</code> 目录下的三个文件，<code>MANIFEST.MF</code>，<code>ANDROID.SF</code>，<code>ANDROID.RSA</code>，他们都是 V1 签名的产物。<br>（1）<code>MANIFEST.MF</code>：这是摘要文件。程序遍历Apk包中的所有文件(entry)，对非文件夹非签名文件的文件，逐个用SHA1(安全哈希算法)生成摘要信息，再用Base64进行编码。如果你改变了apk包中的文件，那么在apk安装校验时，改变后的文件摘要信息与MANIFEST.MF的检验信息不同，于是程序就不能成功安装。</p><img src="/2025/03/05/apk%E7%AD%BE%E5%90%8D%E6%A0%A1%E9%AA%8C/MANIFESTMF.png" class=""><p>（2）<code>ANDROID.SF</code>：这是对摘要的签名文件。对前一步生成的MANIFEST.MF，使用SHA1-RSA算法，用开发者的私钥进行签名。在安装时只能使用公钥才能解密它。解密之后，将它与未加密的摘要信息（即，MANIFEST.MF文件）进行对比，如果相符，则表明内容没有被异常修改。</p><img src="/2025/03/05/apk%E7%AD%BE%E5%90%8D%E6%A0%A1%E9%AA%8C/ANDROIDSF.png" class=""><p>（3）<code>ANDROID.RSA</code>文件中保存了公钥、所采用的加密算法等信息。</p><img src="/2025/03/05/apk%E7%AD%BE%E5%90%8D%E6%A0%A1%E9%AA%8C/ANDROIDRSA.png" class=""><p>在某些情况下，直接对apk进行v1签名可以绕过apk的签名校验.</p><p>v2方案会将 APK 文件视为 blob，并对整个文件进行签名检查。对 APK 进行的任何修改（包括对 ZIP 元数据进行的修改）都会使 APK 签名作废。这种形式的 APK 验证不仅速度要快得多，而且能够发现更多种未经授权的修改。</p><h1 id="签名校验"><a href="#签名校验" class="headerlink" title="签名校验"></a>签名校验</h1><p>什么是签名校验？如何判断是否有签名校验？</p><p>**不做任何修改，直接签名安装，应用闪退则说明大概率有签名校验。**一般来说，普通的签名校验会导致软件的闪退、黑屏、卡启动页等。甚至有一些比较狠的作者，会直接<code>rm -rf /</code>，把基带都格掉的一键变砖。</p><p>一些闪退的指令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">kill/killProcess()   <span class="hljs-comment">// 杀死当前应用活动的进程。这一操作将会把所有该进程内的资源（包括线程全部清理掉）。当然，由于ActivityManager时刻监听着进程，一旦发现进程被非正常Kill，它将会试图去重启这个进程。这就是为什么，有时候当我们试图这样去结束掉应用时，发现它又自动重新启动的原因.</span><br>    <br>system.exit()   <span class="hljs-comment">// 杀死了整个进程，这时候活动所占的资源会被释放。</span><br>    <br>finish()        <span class="hljs-comment">// 仅仅针对Activity，当调用finish()时，只是将活动推向后台，并没有立即释放内存、活动资源。</span><br></code></pre></td></tr></table></figure><h1 id="签名校验对抗"><a href="#签名校验对抗" class="headerlink" title="签名校验对抗"></a>签名校验对抗</h1><p>方法一：<a href="https://github.com/LSPosed/CorePatch">核心破解</a>插件，无需签名安装应用。</p><p>方法二：一键通过签名工具，例如 MT、NP、ARMPro、CNFIX、Modex 的去除签名校验功能。</p><p>方法三：具体分析签名校验逻辑（改smali字节码，手撕签名校验）</p><p>方法四：io重定向</p><p>方法五:去作者家严刑拷打拿到<code>.jks</code>文件和密码</p><h2 id="手撕校验实例"><a href="#手撕校验实例" class="headerlink" title="手撕校验实例"></a>手撕校验实例</h2><p>算法助手 - 开启<code>Log捕获</code> </p><p>下图为拦截到的<code>exit()</code>调用。</p><img src="/2025/03/05/apk%E7%AD%BE%E5%90%8D%E6%A0%A1%E9%AA%8C/log-exit2.png" class=""><p>解决方法：简单粗暴，注释掉 smali码中调用<code>exit()</code>的一行即可。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>java</title>
    <link href="/2025/02/26/java/"/>
    <url>/2025/02/26/java/</url>
    
    <content type="html"><![CDATA[<h2 id="java语言学习"><a href="#java语言学习" class="headerlink" title="java语言学习"></a>java语言学习</h2><h2 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h2><p>由字母、数学、<code>_</code>（下划线）、**<code>$</code>**组成，数字不可以开头。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>android-re</title>
    <link href="/2025/02/11/android-re/"/>
    <url>/2025/02/11/android-re/</url>
    
    <content type="html"><![CDATA[<h1 id="Android逆向"><a href="#Android逆向" class="headerlink" title="Android逆向"></a>Android逆向</h1><h2 id="apk文件结构"><a href="#apk文件结构" class="headerlink" title="apk文件结构"></a>apk文件结构</h2><table><thead><tr><th>文件</th><th>解释</th></tr></thead><tbody><tr><td>assets目录</td><td>存放apk的<strong>静态资源文件</strong>，如视频、音频、图片等。</td></tr><tr><td>lib&#x2F;目录</td><td><code>arm64-v8a</code>只用于64位的Android设备；<code>armeabi-v7a</code>基本通用所有Android设备；<code>x86</code>常见用于安卓模拟器，其目录下的<code>.so</code>文件是c&#x2F;c++编译的动态链接库。</td></tr><tr><td>META-INF目录</td><td>保存应用的<strong>签名信息</strong>，相当于apk的身份证。用于验证apk的完整性，即：文件是否被修改。</td></tr><tr><td>res目录</td><td>存放<strong>资源文件</strong>，包括图片、字符串等等。apk的脸蛋由layout文件设计。</td></tr><tr><td><code>AndroidManifest.xml</code></td><td>apk的应用清单信息，描述了应用的名字，版本，权限，引用的库等等信息。相当于<strong>元数据</strong>（metadata）。</td></tr><tr><td><code>classes.dex</code></td><td><strong>apk运行的主要逻辑</strong>。这是java源码编译后生成的java字节码文件。</td></tr><tr><td><code>resources.arsc</code></td><td>编译后的<strong>二进制资源文件</strong>。它是一个映射表，映射着资源和id，通过id找对应的资源。</td></tr></tbody></table><h2 id="AndroidManifest-xml"><a href="#AndroidManifest-xml" class="headerlink" title="AndroidManifest.xml"></a><code>AndroidManifest.xml</code></h2><p>整个应用程序的信息描述文件，定义了应用程序中包含的Activity、Service、Content Provider和BroadcastReceiver组件信息。每个应用程序根目录下包含一个AndroidManifest.xml文件，且<strong>文件名不能修改</strong>。</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>versionCode</code></td><td>版本号，主要用来更新，例如：<code>12</code></td></tr><tr><td><code>versionName</code></td><td>版本名，给用户看的，例如：<code>1.2</code></td></tr><tr><td><code>package</code></td><td>包名，例如：<code>com.zj.52pj.demo</code></td></tr><tr><td><code>uses-permission android:name=&quot;&quot;</code></td><td>应用权限，例如：<code>android.permission.INTERNET</code>代表网络权限</td></tr><tr><td><code>android:label=&quot;@string/app_name&quot;</code></td><td>应用名称</td></tr><tr><td><code>android:icon=&quot;@mipmap/ic_launcher&quot;</code></td><td>应用图标路径</td></tr><tr><td><code>android:debuggable=&quot;true&quot;</code></td><td>应用是否开启debug权限</td></tr></tbody></table><h2 id="应用双开"><a href="#应用双开" class="headerlink" title="应用双开"></a>应用双开</h2><p>即一个apk安装两遍，成为两个相同应用程序。</p><h2 id="应用汉化"><a href="#应用汉化" class="headerlink" title="应用汉化"></a>应用汉化</h2><h2 id="Dalvik、ART"><a href="#Dalvik、ART" class="headerlink" title="Dalvik、ART"></a>Dalvik、ART</h2><ul><li>Dalvik是Google专门为Android设计的一个虚拟机，有其专属的文件格式<code>.dex</code>（Dalvik executable）</li><li>Art（Android Runtime）相当于Dalvik的升级版，本质与Dalvik无异。</li></ul><h2 id="Smali"><a href="#Smali" class="headerlink" title="Smali"></a>Smali</h2><p>Smali是Dalvik虚拟机使用的一种汇编语言，通过对Android应用的反编译得来（主要是反编译.dex文件）。常用于安卓应用的逆向工程、分析和修改。</p><p>–&gt;<a href="https://ctf-wiki.org/android/basic_operating_mechanism/java_layer/smali/smali">Smali语法</a>&lt;–</p><p>修改Smali代码逻辑可实现应用破解，例如跳过大会员检测。<strong>理解成C#中的IL代码</strong>，修改IL代码也能达到变更应用逻辑的效果，只不过修改方式不同：</p><ul><li>IL：C#中需要用到Harmony类库，编写修改IL代码的patch（本质上是c#代码），然后实现<strong>运行时修改</strong>（动态）。</li><li>Smali：反汇编apk，编辑根目录下<code>classes.dex</code>核心逻辑文件，再保存重新签名、覆盖安装应用，是<strong>编译时修改</strong>（静态）。</li></ul><h2 id="安卓四大组件"><a href="#安卓四大组件" class="headerlink" title="安卓四大组件"></a>安卓四大组件</h2><table><thead><tr><th>组件</th><th>描述</th></tr></thead><tbody><tr><td>Activity（活动）</td><td>每个Activity都表示一个界面。如MainActivity主界面。一个安卓应用必须通过Activity来运行和启动，Activity的生命周期交给系统管理。</td></tr><tr><td>Service（服务）</td><td>在后台执行<strong>长时间操作</strong>且<strong>没有用户界面</strong>的组件。如：后台播放音乐、下载文件等。</td></tr><tr><td>Broadcast Receiver（广播接收器）</td><td>用于接收广播，并做出反应 的组件。常见的系统广播有：通知时区的改变、电量低、语言改变等。</td></tr><tr><td>Content Provider</td><td>接口。</td></tr></tbody></table><h2 id="Activity的生命周期"><a href="#Activity的生命周期" class="headerlink" title="Activity的生命周期"></a>Activity的生命周期</h2><img src="/2025/02/11/android-re/activity-lifecycle.png" class="" title="img"><table><thead><tr><th align="left">函数名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">onCreate()</td><td align="left">一个Activity启动后第一个被调用的函数，常用来在此方法中进行Activity的一些初始化操作。例如创建View，绑定数据，注册监听，加载参数等。</td></tr><tr><td align="left">onStart()</td><td align="left">当Activity显示在屏幕上时，此方法被调用但此时还无法进行与用户的交互操作。</td></tr><tr><td align="left">onResume()</td><td align="left">这个方法在onStart()之后调用，也就是在Activity准备好与用户进行交互的时候调用，此时的Activity一定位于Activity栈顶，处于运行状态。</td></tr><tr><td align="left">onPause()</td><td align="left">这个方法是在系统准备去启动或者恢复另外一个Activity的时候调用，通常在这个方法中执行一些释放资源的方法，以及保存一些关键数据。</td></tr><tr><td align="left">onStop()</td><td align="left">这个方法是在Activity完全不可见的时候调用的。</td></tr><tr><td align="left">onDestroy()</td><td align="left">这个方法在Activity销毁之前调用，之后Activity的状态为销毁状态。</td></tr><tr><td align="left">onRestart()</td><td align="left">当Activity从停止stop状态恢进入start状态时调用状态。</td></tr></tbody></table><h2 id="跳过广告-弹窗的方法"><a href="#跳过广告-弹窗的方法" class="headerlink" title="跳过广告&#x2F;弹窗的方法"></a>跳过广告&#x2F;弹窗的方法</h2><p>广告分为：</p><ul><li>启动广告（开屏广告）</li><li>弹窗&#x2F;更新广告</li><li>横幅广告</li></ul><p>开屏广告的流程：启动activity -&gt; 广告activity -&gt; 主页activity</p><h3 id="Q：如何找到广告activity的类名？"><a href="#Q：如何找到广告activity的类名？" class="headerlink" title="Q：如何找到广告activity的类名？"></a>Q：如何找到广告activity的类名？</h3><p>A：mt管理器 - 左上角三横杠 - Activity记录，打开服务，再进入你的应用，会自动捕捉所有显示过的activity，包括广告的。</p><h3 id="方法1-修改加载时间"><a href="#方法1-修改加载时间" class="headerlink" title="方法1 - 修改加载时间"></a>方法1 - 修改加载时间</h3><p>即，通过修改广告activity本身的代码（如将延迟时间设为零）来跳过广告。下例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Decompiled by Jadx (from NP Manager)</span><br><span class="hljs-comment">//</span><br><span class="hljs-keyword">package</span> com.zj.wuaipojie.ui;<br><br><span class="hljs-keyword">import</span> android.content.Context;<br><span class="hljs-keyword">import</span> android.content.Intent;<br><span class="hljs-keyword">import</span> android.os.Bundle;<br><span class="hljs-keyword">import</span> android.os.Handler;<br><span class="hljs-keyword">import</span> android.os.Message;<br><span class="hljs-keyword">import</span> androidx.appcompat.app.AppCompatActivity;<br><span class="hljs-keyword">import</span> com.zj.wuaipojie.ui.AdActivity$.ExternalSyntheticLambda0;<br><span class="hljs-keyword">import</span> kotlin.Metadata;<br><br><span class="hljs-meta">@Metadata(d1 = &#123;&quot;\u0000(\n\u0002\u0018\u0002\n\u0002\u0018\u0002\n\u0002\b\u0002\n\u0002\u0010\u000b\n\u0000\n\u0002\u0018\u0002\n\u0000\n\u0002\u0010\u0002\n\u0002\b\u0003\n\u0002\u0018\u0002\n\u0002\b\u0005\u0018\u0000 \u00102\u00020\u0001:\u0001\u0010B\u0005¢\u0006\u0002\u0010\u0002J\b\u0010\u0007\u001a\u00020\bH\u0002J\b\u0010\t\u001a\u00020\bH\u0002J\u0012\u0010\n\u001a\u00020\b2\b\u0010\u000b\u001a\u0004\u0018\u00010\fH\u0014J\b\u0010\r\u001a\u00020\bH\u0014J\b\u0010\u000e\u001a\u00020\bH\u0014J\b\u0010\u000f\u001a\u00020\bH\u0014R\u000e\u0010\u0003\u001a\u00020\u0004X\u000e¢\u0006\u0002\n\u0000R\u000e\u0010\u0005\u001a\u00020\u0006X\u0004¢\u0006\u0002\n\u0000¨\u0006\u0011&quot;&#125;, d2 = &#123;&quot;Lcom/zj/wuaipojie/ui/AdActivity;&quot;, &quot;Landroidx/appcompat/app/AppCompatActivity;&quot;, &quot;()V&quot;, &quot;hasPaused&quot;, &quot;&quot;, &quot;timeoutHandler&quot;, &quot;Landroid/os/Handler;&quot;, &quot;jump&quot;, &quot;&quot;, &quot;loadAd&quot;, &quot;onCreate&quot;, &quot;savedInstanceState&quot;, &quot;Landroid/os/Bundle;&quot;, &quot;onDestroy&quot;, &quot;onRestart&quot;, &quot;onStop&quot;, &quot;Companion&quot;, &quot;app_release&quot;&#125;, k = 1, mv = &#123;1, 7, 1&#125;, xi = 48)</span><br><span class="hljs-meta">/* compiled from: AdActivity.kt */</span><br><span class="hljs-meta">public final class AdActivity extends AppCompatActivity &#123;</span><br><span class="hljs-meta">    private static final int AD_TIMEOUT = 3000;</span><br><span class="hljs-meta">    public static final Companion Companion = new Companion(null);</span><br><span class="hljs-meta">    private static final int MSG_AD_TIMEOUT = 1001;</span><br><span class="hljs-meta">    private boolean hasPaused;</span><br><span class="hljs-meta">    private final Handler timeoutHandler = new Handler(new ExternalSyntheticLambda0(this));</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">    private final void jump() &#123;</span><br><span class="hljs-meta">        if (!this.hasPaused) &#123;</span><br><span class="hljs-meta">            this.hasPaused = true;</span><br><span class="hljs-meta">            startActivity(new Intent((Context) this, ChallengeThird.class));</span><br><span class="hljs-meta">            finish();</span><br><span class="hljs-meta">        &#125;</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">    protected void onCreate(Bundle bundle) &#123;</span><br><span class="hljs-meta">        super.onCreate(bundle);</span><br><span class="hljs-meta">        setContentView(2131427362);</span><br><span class="hljs-meta">        loadAd();</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">    protected void onRestart() &#123;</span><br><span class="hljs-meta">        super.onRestart();</span><br><span class="hljs-meta">        this.hasPaused = false;</span><br><span class="hljs-meta">        jump();</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">    protected void onStop() &#123;</span><br><span class="hljs-meta">        this.timeoutHandler.removeMessages(MSG_AD_TIMEOUT);</span><br><span class="hljs-meta">        this.hasPaused = true;</span><br><span class="hljs-meta">        super.onStop();</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">    private final void loadAd() &#123;</span><br><span class="hljs-meta">        this.timeoutHandler.removeMessages(MSG_AD_TIMEOUT);</span><br><span class="hljs-meta">        this.timeoutHandler.sendEmptyMessageDelayed(MSG_AD_TIMEOUT, 3000);</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">    /* renamed from: timeoutHandler$lambda-0 */</span><br><span class="hljs-meta">    private static final boolean m0timeoutHandler$lambda-0(AdActivity adActivity, Message message) &#123;</span><br><span class="hljs-meta">        if (adActivity.hasWindowFocus()) &#123;</span><br><span class="hljs-meta">            adActivity.jump();</span><br><span class="hljs-meta">        &#125;</span><br><span class="hljs-meta">        return false;</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">    protected void onDestroy() &#123;</span><br><span class="hljs-meta">        super.onDestroy();</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">&#125;</span><br></code></pre></td></tr></table></figure><ol><li><strong>广告超时跳转 (<code>jump()</code> 方法)</strong></li></ol><ul><li><code>jump()</code> 方法被用来跳过广告，并且只会在广告页面暂停后跳转。</li><li><code>this.hasPaused</code> 用来检查广告是否已经暂停。如果还没有暂停（即广告未跳过），它会跳转到 <code>ChallengeThird</code> 活动并关闭当前的 <code>AdActivity</code>。</li></ul><ol start="2"><li><strong><code>loadAd()</code> 方法</strong></li></ol><ul><li>该方法用来启动广告的加载逻辑，并且设置了一个超时定时器（3 秒）。</li><li><code>this.timeoutHandler.sendEmptyMessageDelayed(MSG_AD_TIMEOUT, 3000)</code> 会在 3 秒后发送一个消息 (<code>MSG_AD_TIMEOUT</code>) 来触发广告跳过。</li></ul><ol start="3"><li><strong>Handler 处理超时 (<code>timeoutHandler</code>)</strong></li></ol><ul><li><code>timeoutHandler</code> 是一个 <code>Handler</code>，它接收到 <code>MSG_AD_TIMEOUT</code> 消息时，会调用 <code>jump()</code> 方法来跳过广告。</li><li><code>m0timeoutHandler$lambda-0()</code> 这个方法会在消息触发时检查当前窗口是否有焦点，如果有焦点，就调用 <code>jump()</code> 跳过广告。</li></ul><ol start="4"><li><strong>生命周期控制</strong></li></ol><ul><li><strong><code>onCreate()</code></strong>：页面创建时会调用 <code>loadAd()</code> 来加载广告并设置 3 秒超时。</li><li><strong><code>onRestart()</code></strong>：当页面重启时，<code>hasPaused</code> 被重置为 <code>false</code>，并立刻调用 <code>jump()</code> 跳过广告。</li><li><strong><code>onStop()</code></strong>：当页面停止时，会移除超时消息并标记 <code>hasPaused</code> 为 <code>true</code>。</li><li><strong><code>onDestroy()</code></strong>：页面销毁时没有额外逻辑，调用父类的 <code>onDestroy()</code>。</li></ul><p>具体方法：</p><ol><li><strong>修改超时消息的延时</strong>：可以减少 <code>MSG_AD_TIMEOUT</code> 的延时，快速跳过广告。</li></ol><p>修改这一行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">this</span>.timeoutHandler.sendEmptyMessageDelayed(MSG_AD_TIMEOUT, <span class="hljs-number">3000</span>);<br></code></pre></td></tr></table></figure><p>将3000改成50，但不可改成零。因为若没有延时，消息立即被处理，那么<code>hasPaused</code>可能还是<code>true</code>的状态，无法进行<code>jump()</code>的逻辑。</p><p>（通过Smali代码修改）</p><ol start="2"><li><p><strong>直接调用跳转</strong>：可以通过反射或修改代码，直接在 <code>onCreate()</code> 或 <code>onRestart()</code> 中调用 <code>jump()</code> 来跳过广告。</p><p>没试过。。</p></li></ol><h3 id="方法2-Activity切换定位，修改Intent的Activity类名"><a href="#方法2-Activity切换定位，修改Intent的Activity类名" class="headerlink" title="方法2 - Activity切换定位，修改Intent的Activity类名"></a>方法2 - Activity切换定位，修改Intent的Activity类名</h3><h3 id="Q：如何找到相关类在Smali代码中的引用？"><a href="#Q：如何找到相关类在Smali代码中的引用？" class="headerlink" title="Q：如何找到相关类在Smali代码中的引用？"></a>Q：如何找到相关类在Smali代码中的引用？</h3><p>A：1. mt管理器（或np）打开<code>classes.dex</code> </p><ol start="2"><li>搜索原始类名，如<code>com.zj.wuaipojie.ui.AdActivity</code>，搜索类型为<code>类名</code> </li><li>找到正确的类后，长摁 - 复制 - 选择最后一项，如<code>Lcom/zj/wuaipojie/ui/AdActivity;</code> 这是类在Smali中引用时的名字。</li><li>将复制的新名字填入搜索框，搜索类型为<code>代码</code></li></ol><p>下例Intent：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span> (position) &#123;  <br>           <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:  <br>               <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>();  <br>               intent.setClass(it.getContext(), ChallengeFirst.class);  <br>               it.getContext().startActivity(intent);  <br>               <span class="hljs-keyword">return</span>;  <br>           <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:  <br>               <span class="hljs-type">Intent</span> <span class="hljs-variable">intent2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>();  <br>               intent2.setClass(it.getContext(), ChallengeSecond.class);  <br>               it.getContext().startActivity(intent2);  <br>               <span class="hljs-keyword">return</span>;  <br>           <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:  <br>               <span class="hljs-type">Intent</span> <span class="hljs-variable">intent3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>();  <span class="hljs-comment">//new一个Intent，</span><br>               intent3.setClass(it.getContext(), AdActivity.class);  <span class="hljs-comment">//传入要切换的Acitivity的类名</span><br>               it.getContext().startActivity(intent3);  <span class="hljs-comment">//启动对应的Activity</span><br>               <span class="hljs-keyword">return</span>;  <br>           <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:  <br>               <span class="hljs-type">Intent</span> <span class="hljs-variable">intent4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>();  <br>               intent4.setClass(it.getContext(), ChallengeFourth.class);  <br>               it.getContext().startActivity(intent4);  <br>               <span class="hljs-keyword">return</span>; <br>           <span class="hljs-keyword">default</span>:  <br>               <span class="hljs-keyword">return</span>;  <br>       &#125;<br></code></pre></td></tr></table></figure><p>将</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">intent3.setClass(it.getContext(), AdActivity.class);<br></code></pre></td></tr></table></figure><p>中的<code>AdActivity</code>改成页面Activity即可实现跳过广告。</p><h3 id="跳过弹窗法一-修改xml中的versionCode"><a href="#跳过弹窗法一-修改xml中的versionCode" class="headerlink" title="跳过弹窗法一 - 修改xml中的versionCode"></a>跳过弹窗法一 - 修改xml中的versionCode</h3><p>考虑到弹窗有一部分是<strong>更新提示</strong>，可以改版本号跳过更新检测。即，修改<code>AndroidManifest.xml</code>中<code>versionCode</code>和<code>versionName</code>。</p><p>（适用于<strong>已知最新版本号</strong>的前提）</p><h3 id="跳过弹窗法二-Hook弹窗（算法助手）"><a href="#跳过弹窗法二-Hook弹窗（算法助手）" class="headerlink" title="跳过弹窗法二 - Hook弹窗（算法助手）"></a>跳过弹窗法二 - Hook弹窗（<a href="https://blog.csdn.net/u014645251/article/details/119030982">算法助手</a>）</h3><p>（针对那些劫持返回键的弹窗）</p><p>算法助手 - 开启对应应用的<code>应用总开关</code>和<code>UI</code>下的<code>弹窗定位（返回键可取消）</code>，再点击右上角的小三角启动应用。被劫持的返回键又能用了！</p><p>（屏蔽关键词弹窗）</p><p>算法助手 - 开启对应应用的<code>应用总开关</code> 和 <code>UI</code>下的<code>屏蔽关键词弹窗</code>，输入弹窗中模糊&#x2F;精确的关键词，如”广告”，即可一键屏蔽所有使用该关键词的广告！</p><h3 id="跳过弹窗法三-修改dex代码"><a href="#跳过弹窗法三-修改dex代码" class="headerlink" title="跳过弹窗法三 - 修改dex代码"></a>跳过弹窗法三 - 修改dex代码</h3><p>step1：定位弹窗位于哪个方法中。可利用 <code>算法助手 - 日志 - 某个Dialog弹窗 - 调用堆栈</code> 查看。</p><p>step2：<strong>一般弹窗需要调用 <code>xxxDialog.show()</code>方法才能显示</strong>。因此把Smali中调用<code>.show()</code>方法的语句注释掉即可。</p><h2 id="跳过横幅广告的方法"><a href="#跳过横幅广告的方法" class="headerlink" title="跳过横幅广告的方法"></a>跳过横幅广告的方法</h2><p>step1: <a href="https://github.com/TimeShining/Android-Dev-Tools">开发助手</a> - 布局查看（需启用无障碍权限）- 切到横幅应用 - 点击悬浮窗上的放大镜图标 - 定位横幅广告 - 复制<code>View Id(Hex)</code></p><p>step2: mt管理器 - 进入目标应用apk - <code>XML搜索</code> - 搜索刚刚复制的<code>View Id</code>（十六进制，搜索类型 <code>资源ID</code>）</p><p>下例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">                    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@7F0801CA&quot;</span>           &lt;!<span class="hljs-attr">--</span> <span class="hljs-attr">十六进制ViewId</span> <span class="hljs-attr">--</span>&gt;</span><br>                    android:background=&quot;@7F0D0017&quot;<br>                    android:layout_width=&quot;-2&quot;        <span class="hljs-comment">&lt;!-- 弹窗宽度，-2代表 wrap_content 自适应--&gt;</span><br>                    android:layout_height=&quot;150dp&quot;    <span class="hljs-comment">&lt;!-- 弹窗高度 --&gt;</span><br>                    android:layout_marginTop=&quot;100dp&quot; /&gt;<br></code></pre></td></tr></table></figure><p>要跳过横幅，只需把宽高全调成<code>0dp</code>即可。</p><h2 id="Jeb-Decompiler"><a href="#Jeb-Decompiler" class="headerlink" title="Jeb Decompiler"></a>Jeb Decompiler</h2><p>一款安卓的反编译工具，可进行<strong>动态调试</strong>。</p><h2 id="利用-Jeb-动态调试"><a href="#利用-Jeb-动态调试" class="headerlink" title="利用 Jeb 动态调试"></a>利用 Jeb 动态调试</h2><p>简记一个步骤。</p><ol><li><p>打开安卓usb调试功能。设置 - 点击版本号7次进入开发者选项 - 启用<code>USB调试</code></p></li><li><p>设置应用可调试权限（debuggable）。打开<code>AndroidManifest.xml</code> - 添加<code>android:debuggable=&quot;true&quot;</code> - 保存覆盖安装</p></li><li><p>pc命令行输入adb指令。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">adb <span class="hljs-keyword">shell</span> <span class="hljs-keyword">am</span> start -D -n 包名/类名<br><br>例如：<br>adb <span class="hljs-keyword">shell</span> <span class="hljs-keyword">am</span> start -D -n <span class="hljs-keyword">com</span>.zj.wuaipojie/.ui.MainActivity<br></code></pre></td></tr></table></figure></li><li><p>打开jeb，拖入应用apk反编译。点击<code>开始</code>图标开始调试。</p><img src="/2025/02/11/android-re/jeb-start.png" class="" title="image-20250304001621185"><p>确保进程名和你的应用一致（图中为<code>com.zj.wuaipojie</code>），点击<code>附上</code>。</p><img src="/2025/02/11/android-re/jeb-attch.png" class=""></li><li><p>正式开始调试。光标停在某一行smali字节码上，<code>ctrl+B</code>下断点。</p><img src="/2025/02/11/android-re/jeb-debug.png" class=""></li></ol><h2 id="Log插桩"><a href="#Log插桩" class="headerlink" title="Log插桩"></a>Log插桩</h2><p>Log插桩指的是反编译APK文件时，在对应的smali文件里，添加相应的smali代码，将程序中的关键信息，以log日志的形式进行输出。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>python</title>
    <link href="/2025/02/09/python/"/>
    <url>/2025/02/09/python/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/02/08/hello-world/"/>
    <url>/2025/02/08/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>misc</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
